<?php
namespace widget;


/**
 * DataColumn is the default column type for the [[GridView]] widget.
 *
 * It is used to show data columns and allows [[enableSorting|sorting]] and [[filter|filtering]] them.
 *
 * A simple data column definition refers to an attribute in the data model of the
 * GridView's data provider. The name of the attribute is specified by [[attribute]].
 *
 * By setting [[value]] and [[label]], the header and cell content can be customized.
 *
 * A data column differentiates between the [[getDataCellValue|data cell value]] and the
 * [[renderDataCellContent|data cell content]]. The cell value is an un-formatted value that
 * may be used for calculation, while the actual cell content is a [[format|formatted]] version of that
 * value which may contain HTML markup.
 *
 * @author Qiang Xue <qiang.xue@gmail.com>
 * @since 2.0
 */
class DataColumn extends Column {

    public function __construct(array $config = array()) {
	$defaults = array(
	    'attribute' => null,
	    'label' => null,
	    'encodeLabel' => true,
	    'value' => null,
	    'filter' => null,
	    'filterInputOptions' => array(
		'class' => 'form-control',
		'id' => null,
	    ),
	    'sortLinkOptions' => array(
	    ),
	);
	if (!isset($config['grid']))
	    throw new \InvalidArgumentException('column: missing grid in constructor');

	$config = \util\Set::merge($defaults, $config);
	parent::__construct($config);
    }

    /**
     * @var string the attribute name associated with this column. When neither [[content]] nor [[value]]
     * is specified, the value of the specified attribute will be retrieved from each data model and displayed.
     *
     * Also, if [[label]] is not specified, the label associated with the attribute will be displayed.
     */
    //public $attribute;
    /**
     * @var string label to be displayed in the [[header|header cell]] and also to be used as the sorting
     * link label when sorting is enabled for this column.
     * If it is not set and the models provided by the GridViews data provider are instances
     * of [[\yii\db\ActiveRecord]], the label will be determined using [[\yii\db\ActiveRecord::getAttributeLabel()]].
     * Otherwise [[\yii\helpers\Inflector::camel2words()]] will be used to get a label.
     */
    //public $label;
    /**
     * @var boolean whether the header label should be HTML-encoded.
     * @see label
     * @since 2.0.1
     */
    //public $encodeLabel = true;
    /**
     * @var string|\Closure an anonymous function or a string that is used to determine the value to display in the current column.
     *
     * If this is an anonymous function, it will be called for each row and the return value will be used as the value to
     * display for every data model. The signature of this function should be: `function ($model, $key, $index, $column)`.
     * Where `$model`, `$key`, and `$index` refer to the model, key and index of the row currently being rendered
     * and `$column` is a reference to the [[DataColumn]] object.
     *
     * You may also set this property to a string representing the attribute name to be displayed in this column.
     * This can be used when the attribute to be displayed is different from the [[attribute]] that is used for
     * sorting and filtering.
     *
     * If this is not set, `$model[$attribute]` will be used to obtain the value, where `$attribute` is the value of [[attribute]].
     */
    //public $value;

    /**
     * @var array the HTML attributes for the link tag in the header cell
     * generated by [[\yii\data\Sort::link]] when sorting is enabled for this column.
     * @see \yii\helpers\Html::renderTagAttributes() for details on how attributes are being rendered.
     */
    //public $sortLinkOptions = [];
    /**
     * @var string|array|boolean the HTML code representing a filter input (e.g. a text field, a dropdown list)
     * that is used for this data column. This property is effective only when [[GridView::filterModel]] is set.
     *
     * - If this property is not set, a text field will be generated as the filter input;
     * - If this property is an array, a dropdown list will be generated that uses this property value as
     *   the list options.
     * - If you don't want a filter for this data column, set this value to be false.
     */
    //public $filter;
    /**
     * @var array the HTML attributes for the filter input fields. This property is used in combination with
     * the [[filter]] property. When [[filter]] is not set or is an array, this property will be used to
     * render the HTML attributes for the generated filter input fields.
     * @see \yii\helpers\Html::renderTagAttributes() for details on how attributes are being rendered.
     */
    //public $filterInputOptions = ['class' => 'form-control', 'id' => null];


    /**
     * @inheritdoc
     */
    protected function renderHeaderCellContent($model = null) {
        if ($this->header !== null || $this->label === null && $this->attribute === null) {
            return parent::renderHeaderCellContent($model);
        }

        if ($this->label === null) {
            $label = $this->attribute;
        } else {
            $label = $this->label;
        }


	//echo "{$this->attribute} is set: " . array_key_exists($this->attribute, $this->grid->sortObject->attributes);
        if ($this->attribute !== null && ($sort = $this->grid->__sort) !== null && array_key_exists($this->attribute, $this->grid->__sort->attributes) && ($sorter = $this->grid->__sorter) !== null) {
            return $sorter->link($this->attribute, $this->sortLinkOptions + ['label' => $label]);
        } else {
            return $label;
        }
    }


    protected function renderFilterCellContent($model = null) {
        if (is_string($this->filter)) {
            return $this->filter;
        }
	if ($this->filter === false)
            return parent::renderFilterCellContent($model);

        $model = $this->grid->filterModel;

	$attr = $this->attribute;
	if (is_bool($model->$attr)) {
	    $model->$attr = (int)$model->$attr;
	}

	if (is_array($this->filter)) {
	    //render a dropdown
	    //return $this->grid->_filter_form->select($this->attribute, ['' => ''] + $this->filter, $this->filterInputOptions);
	    return Widget::form()->select($this->attribute, ['' => ''] + $this->filter, $this->filterInputOptions);
	} elseif (!empty($this->filter) && $this->filter !== false) {
	    //render a textbox
	    //return $this->grid->_filter_form->text($this->attribute, $this->filterInputOptions);
	    return Widget::form()->text($this->attribute, $this->filterInputOptions);
	}
/*
        if ($model instanceof Model && $this->attribute !== null && $model->isAttributeActive($this->attribute)) {
            if ($model->hasErrors($this->attribute)) {
                Html::addCssClass($this->filterOptions, 'has-error');
                $error = ' ' . Html::error($model, $this->attribute, $this->grid->filterErrorOptions);
            } else {
                $error = '';
            }
            if (is_array($this->filter)) {
                $options = array_merge(['prompt' => ''], $this->filterInputOptions);
                return Html::activeDropDownList($model, $this->attribute, $this->filter, $options) . $error;
            } else {
                return Html::activeTextInput($model, $this->attribute, $this->filterInputOptions) . $error;
            }
        } else {
            return parent::renderFilterCellContent($model);
        }
*/
    }

    // Returns the data cell value.
    public function getDataCellValue($model) {
        if ($this->value !== null) {
            if (is_string($this->value)) {
        	return $model->data()[$this->value];
            } elseif (is_callable($this->value)) {
                return call_user_func($this->value, $model, $this);
            }
        } elseif ($this->attribute !== null) {
            return $model->data()[$this->attribute];
        }
        return null;
    }

    /**
     * @inheritdoc
     */
    protected function renderContentCellContent($model = null) {
	if ($this->content === null) {
	    return $this->getDataCellValue($model);
	}
        return parent::renderContentCellContent($model);
    }
}
